/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { SECURITY_CONFIG } from '../domain/security-config';
export class LoginService {
    /**
     * @param {?} http
     * @param {?} securityConfig
     */
    constructor(http, securityConfig) {
        this.http = http;
        this.ursUrl = 'api/v1/auth';
        this.securityConfig = securityConfig;
    }
    /**
     * @param {?} idToken
     * @return {?}
     */
    login(idToken) {
        /** @type {?} */
        const url = this.securityConfig.authorization_service_url + this.ursUrl;
        return this.http
            .post(url, idToken, { observe: 'response', responseType: 'text' })
            .pipe(map((/**
         * @param {?} response
         * @return {?}
         */
        (response) => response.body)), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => this.handleError(error))));
    }
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        const errorMessage = error.message ? error.message : error.toString();
        console.error(errorMessage);
        return throwError(errorMessage);
    }
}
LoginService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
LoginService.ctorParameters = () => [
    { type: HttpClient },
    { type: undefined, decorators: [{ type: Inject, args: [SECURITY_CONFIG,] }] }
];
if (false) {
    /** @type {?} */
    LoginService.prototype.securityConfig;
    /**
     * @type {?}
     * @private
     */
    LoginService.prototype.ursUrl;
    /**
     * @type {?}
     * @private
     */
    LoginService.prototype.http;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9naW4uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BmeC1saWIvY29tcG9uZW50cy8iLCJzb3VyY2VzIjpbImxpYi9meC1zZWN1cml0eS9zZXJ2aWNlcy9sb2dpbi5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQTtBQUVsRCxPQUFPLEVBQUUsVUFBVSxFQUFtQyxNQUFNLHNCQUFzQixDQUFBO0FBRWxGLE9BQU8sRUFBYyxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUE7QUFDN0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQTtBQUNoRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMkJBQTJCLENBQUE7QUFHM0QsTUFBTSxPQUFPLFlBQVk7Ozs7O0lBS3ZCLFlBQW9CLElBQWdCLEVBQ1QsY0FBOEI7UUFEckMsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUY1QixXQUFNLEdBQUcsYUFBYSxDQUFBO1FBSzVCLElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFBO0lBQ3RDLENBQUM7Ozs7O0lBRU0sS0FBSyxDQUFDLE9BQXlCOztjQUM5QixHQUFHLEdBQVcsSUFBSSxDQUFDLGNBQWMsQ0FBQyx5QkFBeUIsR0FBRyxJQUFJLENBQUMsTUFBTTtRQUUvRSxPQUFPLElBQUksQ0FBQyxJQUFJO2FBQ2IsSUFBSSxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsQ0FBQzthQUNqRSxJQUFJLENBQ0gsR0FBRzs7OztRQUFDLENBQUMsUUFBMkIsRUFBRSxFQUFFLENBQ2xDLFFBQVEsQ0FBQyxJQUFJLEVBQ2QsRUFDRCxVQUFVOzs7O1FBQUMsQ0FBQyxLQUF3QixFQUFFLEVBQUUsQ0FDdEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFDeEIsQ0FDRixDQUFBO0lBQ0wsQ0FBQzs7Ozs7O0lBRU8sV0FBVyxDQUFDLEtBQXdCOztjQUNwQyxZQUFZLEdBQVcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtRQUM3RSxPQUFPLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFBO1FBRTNCLE9BQU8sVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFBO0lBQ2pDLENBQUM7OztZQWhDRixVQUFVOzs7O1lBTkYsVUFBVTs0Q0FhZCxNQUFNLFNBQUMsZUFBZTs7OztJQUx6QixzQ0FBcUM7Ozs7O0lBRXJDLDhCQUE4Qjs7Ozs7SUFFbEIsNEJBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSdcclxuaW1wb3J0IHsgU2VjdXJpdHlDb25maWcgfSBmcm9tICcuLi9meC1zZWN1cml0eS5tb2R1bGUnXHJcbmltcG9ydCB7IEh0dHBDbGllbnQsIEh0dHBFcnJvclJlc3BvbnNlLCBIdHRwUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCdcclxuaW1wb3J0IHsgSWRwSWRlbnRpdHlUb2tlbiB9IGZyb20gJy4vYXV0aGVudGljYXRpb24uc2VydmljZSdcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnXHJcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJ1xyXG5pbXBvcnQgeyBTRUNVUklUWV9DT05GSUcgfSBmcm9tICcuLi9kb21haW4vc2VjdXJpdHktY29uZmlnJ1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTG9naW5TZXJ2aWNlIHtcclxuICBwdWJsaWMgc2VjdXJpdHlDb25maWc6IFNlY3VyaXR5Q29uZmlnXHJcblxyXG4gIHByaXZhdGUgdXJzVXJsID0gJ2FwaS92MS9hdXRoJ1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHA6IEh0dHBDbGllbnQsXHJcbiAgICBASW5qZWN0KFNFQ1VSSVRZX0NPTkZJRykgc2VjdXJpdHlDb25maWc6IFNlY3VyaXR5Q29uZmlnKSB7XHJcblxyXG4gICAgdGhpcy5zZWN1cml0eUNvbmZpZyA9IHNlY3VyaXR5Q29uZmlnXHJcbiAgfVxyXG5cclxuICBwdWJsaWMgbG9naW4oaWRUb2tlbjogSWRwSWRlbnRpdHlUb2tlbik6IE9ic2VydmFibGU8c3RyaW5nPiB7XHJcbiAgICBjb25zdCB1cmw6IHN0cmluZyA9IHRoaXMuc2VjdXJpdHlDb25maWcuYXV0aG9yaXphdGlvbl9zZXJ2aWNlX3VybCArIHRoaXMudXJzVXJsXHJcblxyXG4gICAgcmV0dXJuIHRoaXMuaHR0cFxyXG4gICAgICAucG9zdCh1cmwsIGlkVG9rZW4sIHsgb2JzZXJ2ZTogJ3Jlc3BvbnNlJywgcmVzcG9uc2VUeXBlOiAndGV4dCcgfSlcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgbWFwKChyZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4pID0+XHJcbiAgICAgICAgICByZXNwb25zZS5ib2R5XHJcbiAgICAgICAgKSxcclxuICAgICAgICBjYXRjaEVycm9yKChlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpID0+XHJcbiAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yKVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogSHR0cEVycm9yUmVzcG9uc2UpOiBPYnNlcnZhYmxlPG5ldmVyPiB7XHJcbiAgICBjb25zdCBlcnJvck1lc3NhZ2U6IHN0cmluZyA9IGVycm9yLm1lc3NhZ2UgPyBlcnJvci5tZXNzYWdlIDogZXJyb3IudG9TdHJpbmcoKVxyXG4gICAgY29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2UpXHJcblxyXG4gICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3JNZXNzYWdlKVxyXG4gIH1cclxufVxyXG4iXX0=